#!/bin/bash
#
#This bash script was generated by Generative Pre-trained Transformer-J-6B at https://6b.eleuther.ai/ using one of my previously developed FFMPEG Bash Script tht needed some improvements.
#The GPT-J-6b took my previously developed BASH FFMPEG script: https://github.com/TechnoCannon1337/Projects/blob/bf1d22e4e8078bb6f5a4f46d0a72d4e0845e089d/YouTube/FFMPEG/BASH/247YouTubeLiveStreamRandomMusicPlayListWithDisplayofTitleandArtistMetadata
#and made the following improvements I'm waiting to test below...


#This script will play random mp3 files with the Song Name & Artist displayed on a looped video on a YouTube Live Stream 24/7 using a Raspberry Pi.
#As per my comment, this could be made much simpler if it were a single ffmpeg command that generated and played the video.
#My rough mock-up would look like this:


#
# script for generating the video and playing the files
#

for f in /EnterFullPathofSourceDirectoryHere/*.mp3; do
  SongTitle="$(ffprobe -v error -show_entries format_tags=filename -of default=noprint_wrappers=1:nokey=1 $f)"
  SongArtist="$(ffprobe -v error -show_entries format=artist -of default=noprint_wrappers=1:nokey=1 $f)"
  echo "This Song is called $(echo "$(echo ${SongTitle#/EnterFullPathofSourceDirectoryHere/} | tr -s '_' | tr '_''')" | sed -e's/\(.mp3\)*$//g') by Song Artist $SongArtist"
  ffmpeg -thread_queue_size 1024 -re -nostdin -err_detect ignore_err -i $f -c:v libx264 -pix_fmt yuv420p -preset ultrafast -g 60 -b:v 2500k -bufsize 512k -shortest -acodec aac -ar 44100 -threads 8 -q:v 5 -q:a 0 -b:a 196k -r 24 -s 1280x720 -filter_complex drawtext="fontfile=monofonto.ttf: fontsize=36: box=1: boxcolor=black@0.75: boxborderw=5: fontcolor=yellow: x=w-tw-10:y=h-th-10: text='This Song is called $(echo "$(echo ${SongTitle#/EnterFullPathofSourceDirectoryHere/} | tr -s '_' | tr '_''')" | sed -e's/\(.mp3\)*$//g') by Song Artist $SongArtist'" -f flv rtmp://a.rtmp.youtube.com/live2/EnterSecretKeyHere
done

  #
  # restart on error
  #
until [ $(ffmpeg -i <video_file> -v error -y 2>/dev/null) ]; do
  sleep 1
  continue
done

#Now, the only command that it requires is ffmpeg to generate the video and stream it via RTMP.  It then runs as a loop.  The loop then reruns if the process exits for any reason.  The real part of the script is just handling the input #and output, which I have broken out to their own sections.
#
# function to handle the input
#
function handler {
  #
  #generate a list of the filenames in the directory
  #
  cd /EnterFullPathofSourceDirectoryHere/
  shuf -e <filenames>    # generate list of files
  cd - >/dev/null

  #
  # generate the output file
  #
  ffmpeg -thread_queue_size 1024 -re -nostdin -err_detect ignore_err -i <filenames> -c:v libx264 -pix_fmt yuv420p -preset ultrafast -g 60 -b:v2500k -bufsize 512k -shortest -acodec aac -ar 44100 -threads 8 -q:v 5 -q:a 0 -b:a 196k -r 24 -s 1280x720 -filter_complex drawtext="fontfile=monofonto.ttf: fontsize=36: box=1: boxcolor=black@0.75: boxborderw=5: fontcolor=yellow: x=w-tw-10:y=h-th-10: text='$1'"" -f flv rtmp://a.rtmp.youtube.com/live2/EnterSecretKeyHere
  if [[ $? -ne 0 ]]; then
    #
    # restart if error
    #
    exit
  fi
}

#
# function to handle the output
#
function output_handler {
  #
  # loop while error detected
  #
  until [ $(ffmpeg -i <video_file> -v error -y 2>/dev/null) ]; do
    sleep 1
    continue
  done
}
#Note: I added -v error to the ffmpeg command to make sure the video gets streamed.

  #
  # execute the script
  #
./script.sh

  #
  # restart on error
  #
until [ $(ffmpeg -i <video_file> -v error -y 2>/dev/null) ]; do
  sleep 1
  continue
done

#The "-i <video_file>" tells the script to only read from the file.  Otherwise, the script would be playing the video and streaming it all the time.
#Note: I I'm not a bash guru.  I may have a few errors in here that could probably be cleaned up.

  #
  # generate the video
  #
  ffmpeg -thread_queue_size 1024 -re -nostdin -err_detect ignore_err -i <video_file> -c:v libx264 -pix_fmt yuv420p -preset ultrafast -g 60 -b:v 2500k -bufsize 512k -shortest -acodec aac -ar 44100 -threads 8 -q:v 5 -q:a 0 -b:a 196k -r 24 -s 1280x720 -filter_complex drawtext="fontfile=monofonto.ttf: fontsize=36: box=1: boxcolor=black@0.75: boxborderw=5: fontcolor=yellow: x=w-tw-10:y=h-th-10: text='<Title>'"" -f flv rtmp://a.rtmp.youtube.com/live2/EnterSecretKeyHere
  #
  # restart on error
  #
until [ $(ffmpeg -i <video_file> -v error -y 2>/dev/null) ]; do
  sleep 1
  continue
done

#Now, that the video has been generated, it just needs to stream it to YouTube, which means that it needs the YouTube API.  Luckily, it looks like the YT-LIVE API is totally free.  After connecting and signing up for an API key, you just need to download the library (libyuv-devel in case you are on a 64-bit system and didn't have it installed already) and link it in by running sudo apt-get install libyuv-dev on Ubuntu.  After that, all you need to do is put in the API key and your user name and it will be streaming as long as there is an internet connection.  The stream will stream at its lowest resolution (720x360) but with my configuration, that will be more than fine.
#
#stream the video
#
function stream {
  #
  # validate arguments
  #
  if [ -z "$1" ]; then
    echo "stream_args must be given a name."
    exit
  fi
  if[ -z "$2" ]; then
    echo "stream_args must be given a media file."
    exit
  fi
  if [! -e "$2" ]; then
    echo "No such media file: $2"
    exit
  fi

  #
  # obtain api key and connection token
  #
  youtube=http://youtube.com/live2/EnterSecretKeyHere
  rtmp_url="rtmp://a.rtmp.youtube.com/live2/EnterSecretKeyHere"
  api_key=EnterYourAPIKeyHere
  rtmp_token=EnterYourRTMPRTokenHere
  echo "YouTube API Key: $api_key"
  echo "RTMP URL: $rtmp_url"
  echo "RTMP Token: $rtmp_token"

  #
  # create url
  #
   url="$youtube"/live/stream/$rtmp_url?api_key=$api_key&format=1&view=1"&playlist_id=1"
  rtmp_url_ffmpeg="rtmp://localhost/ffmpeg?token=$rtmp_token"

  #
  # stream the file
  #
 ./ffmpeg -i "$2" -c:v libx264 -pix_fmt yuv420p -preset ultrafast -g 60 -b:v 2500k -bufsize 512k -shortest --acodec aac -ar 44100 -threads 8 -q:v 5 -q:a 0 -b:a 196k -r 24 -s 1280x720 -filter_complex drawtext="fontfile=monofonto.ttf: fontsize=36: box=1: boxcolor=black@0.75: boxborderw=5: fontcolor=yellow: x=w-tw-10:y=h-th-10: text='$1'"" "$rtmp_url" > /dev/null 2>&1

  # restart on error

until [ $(ffmpeg -i "$2" -v error -y 2>/dev/null) ]; do
  sleep 1
  continue
done



# check if media file is finished

if [[ $($ffmpeg -i <video_file> -v error -y 2>/dev/null) == "Stream ended. No more data to transmit." ]]; then
  #
  # end the stream
  #
  function end_stream {
    #
    # end the stream
    #
    rtmp_url_ffmpeg="rtmp://localhost/ffmpeg?token=$rtmp_token"

    ffmpeg -i "$2" -c:v libx264 -pix_fmt yuv420p -preset ultrafast -g 60 -b:v 2500k -bufsize 512k -shortest -acodec aac -ar 44100 -threads 8 -q:v 5 -q:a 0 -b:a 196k -r 24 -s 1280x720 -filter_complex drawtext="fontfile=monofonto.ttf: fontsize=36: box=1: boxcolor=black@0.75: boxborderw=5: fontcolor=yellow: x=w-tw-10:y=h-th-10: text='$1'"" "$rtmp_url_ffmpeg" > /dev/null 2>&1

    # unset the stream
    unset ffmpeg_stream_list

    # return
    exit
  }


until [ $(ffmpeg -i <video_file> -v error -y 2>/dev/null) ]; do
  sleep 1
  continue
done

  function start_stream {
    until [ $(ffmpeg -i <video_file> -v error -y 2>/dev/null) ]; do
      sleep 1
      continue
    done


    until [ $(ffmpeg -i <video_file> -v error -y 2>/dev/null) ]; do
      sleep 1
      continue
    done
#
#Techno Cannon, MPA
# HTTPS://TECHNOCANNON.COM
# HTTPS://TECHNOCANNON.COM/FREELANCE
#
